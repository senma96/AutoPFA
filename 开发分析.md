# AutoPFA 开发分析文档

## 目录
1. [图标修改分析](#1-图标修改分析)
2. [算法新增分析](#2-算法新增分析)

---

# 1. 图标修改分析

## 1.1 资源文件位置

所有图标资源位于 `AutoPFA/res/` 目录下：

```
AutoPFA/res/
├── 应用图标 (.ico)
│   ├── AutoPFA.ico          # 主程序图标
│   ├── AutoPFADoc.ico       # 文档图标
│   └── icon1.ico            # 其他图标
│
├── 工具栏图标 (.bmp)
│   ├── Toolbar.bmp          # 主工具栏
│   ├── toolbar1.bmp         # 辅助工具栏
│   ├── graphbar.bmp         # 图形工具栏
│   └── palette.bmp          # 调色板/组件面板
│
├── 组件图标 (.bmp)
│   ├── bitmap1.bmp ~ bitmap20.bmp    # 管网组件图标
│   ├── bmp00001.bmp ~ bmp00018.bmp   # 更多组件图标
│   ├── resvior25.bmp/50.bmp/75.bmp   # 水库图标（不同状态）
│   └── angel1.bmp, angel21.bmp       # 角度相关图标
│
└── 界面图标 (.bmp)
    ├── uesoftci.bmp          # 公司Logo
    ├── tick_*.bmp            # 复选标记图标
    ├── greenlig.bmp          # 绿灯指示
    ├── RedLight.bmp          # 红灯指示
    └── 水头损失公式.bmp       # 公式说明图
```

## 1.2 资源定义文件

**资源脚本文件**：`AutoPFA/AutoPFA.rc`

**资源ID定义**：`AutoPFA/Resource.h`

## 1.3 图标修改方法

### 方法一：直接替换图片文件（最简单）

| 步骤 | 操作 | 难度 |
|------|------|------|
| 1 | 准备新图标（保持相同尺寸和格式） | ⭐ |
| 2 | 备份原文件 | ⭐ |
| 3 | 用新图标覆盖原文件 | ⭐ |
| 4 | 重新编译 | ⭐ |

**难度**：⭐ 简单

**注意事项**：
- BMP 文件必须保持原尺寸（如 16x16, 32x32）
- 工具栏图标是横向排列的长条图，每个图标 16x15 像素
- 颜色深度保持一致（通常为 256 色或 24 位）

### 方法二：添加新图标资源

1. **在 VS2022 中操作**：
   - 资源视图 → 右键 AutoPFA.rc → 添加资源 → Bitmap/Icon
   - 导入图片文件

2. **手动编辑 .rc 文件**：
```cpp
// 在 AutoPFA.rc 中添加
IDB_NEW_BITMAP    BITMAP    "res\\newbitmap.bmp"
IDI_NEW_ICON      ICON      "res\\newicon.ico"
```

3. **在 Resource.h 中定义 ID**：
```cpp
#define IDB_NEW_BITMAP    200
#define IDI_NEW_ICON      201
```

**难度**：⭐⭐ 中等

### 方法三：修改工具栏图标

工具栏图标存储在单个 BMP 文件中，所有按钮图标横向排列。

**`Toolbar.bmp` 结构**：
```
[图标1][图标2][图标3]...[图标N]
  16px   16px   16px      16px
```

**修改步骤**：
1. 用图像编辑软件（如 Photoshop、GIMP）打开 `Toolbar.bmp`
2. 定位要修改的图标位置（每个 16x15 像素）
3. 替换图标内容
4. 保存并重新编译

**难度**：⭐⭐ 中等

### 方法四：修改左侧组件面板图标

左侧的组件图标面板由 `palette.bmp` 或多个独立 BMP 文件组成。

**相关代码**：
- `AutoPFA/ToolBox.cpp` - 工具箱控件
- `AutoPFA/ToolPalette.cpp` - 工具面板

**难度**：⭐⭐⭐ 中等偏难

## 1.4 图标修改难度总结

| 修改类型 | 难度 | 所需技能 | 预计时间 |
|---------|------|---------|---------|
| 替换应用图标 (.ico) | ⭐ | 基础 | 5分钟 |
| 替换单个组件图标 | ⭐ | 基础 | 10分钟 |
| 修改工具栏图标 | ⭐⭐ | 图像编辑 | 30分钟 |
| 添加新图标资源 | ⭐⭐ | VS资源编辑 | 1小时 |
| 重新设计组件面板 | ⭐⭐⭐ | 图像编辑+代码 | 半天 |
| 全套图标重新设计 | ⭐⭐⭐⭐ | 设计+开发 | 2-3天 |

---

# 2. 算法新增分析

## 2.1 算法架构概述

项目使用 **MOC（Method of Characteristics，特征线法）** 进行管网瞬变流分析。

### 核心模块

```
算法模块层次结构：

CalcInterface/          # 计算接口层（数据转换）
    ↓
CalcDriver/             # 计算驱动层（调度控制）
    ↓
MocCalc/                # MOC计算核心（算法实现）
    ├── 管道计算 (MOCPipe)
    ├── 节点计算 (MOCJun系列)
    ├── 稳态计算 (MOCSteady)
    └── 瞬变计算 (MOCTrans)
```

## 2.2 MocCalc 模块详解

### 2.2.1 核心类结构

```
MocCalc/
├── 管道计算
│   ├── MOCPipe.cpp           # 管道计算核心
│   ├── MOCStation.cpp        # 管道站点
│   ├── MOCStationMgr.cpp     # 站点管理器
│   └── CalcFriction.cpp      # 摩擦系数计算
│
├── 节点计算（各种边界条件）
│   ├── MOCJun.cpp            # 节点基类
│   ├── MOCReservior.cpp      # 水库节点
│   ├── MOCPump.cpp           # 泵节点
│   ├── MOCValve.cpp          # 阀门节点
│   ├── MOCGeneral.cpp        # 通用阻力节点
│   ├── MOCCheck.cpp          # 止回阀
│   ├── MOCControl.cpp        # 控制阀
│   ├── MOCRelief.cpp         # 安全阀
│   ├── MOCSurge.cpp          # 调压塔
│   ├── MOCGasAccum.cpp       # 气罐
│   ├── MOCLiquidAccum.cpp    # 液罐
│   ├── MOCSpray.cpp          # 喷嘴
│   ├── MOCBrach.cpp          # 分支节点
│   ├── MOCTeeWye.cpp         # 三通/Y型
│   ├── MOCBend.cpp           # 弯头
│   ├── MOCAreaChange.cpp     # 变径管
│   ├── MOCBrecker.cpp        # 真空破坏器
│   ├── MOCDeadEnd.cpp        # 盲端
│   ├── MOCAssignFlow.cpp     # 指定流量
│   └── MOCAssignPress.cpp    # 指定压力
│
├── 策略模式类（计算策略）
│   ├── LocalRStrategy.cpp          # 局部阻力策略
│   ├── PressDropStrategy.cpp       # 压降策略
│   ├── GasAccumStrategy.cpp        # 气罐策略
│   ├── LiquidAccumStrategy.cpp     # 液罐策略
│   ├── SurgeStrategy.cpp           # 调压塔策略
│   └── BreckerStrategy.cpp         # 真空破坏器策略
│
├── 泵模型
│   ├── MOCPumpModel.cpp            # 泵模型基类
│   ├── FourQundrantModel.cpp       # 四象限模型
│   ├── MOCFourQuadrantData.cpp     # 四象限数据
│   ├── MOCLumpedInertia.cpp        # 集中惯性模型
│   ├── StartFourQundrant.cpp       # 启动四象限
│   ├── TripFourQundrant.cpp        # 停泵四象限
│   ├── WhitoutInertia.cpp          # 无惯性模型
│   └── WhitoutInertiaFourQundrant.cpp
│
├── 触发器系统（瞬变控制）
│   ├── MOCTriger.cpp               # 触发器基类
│   ├── MOCTrigerMgr.cpp            # 触发器管理
│   ├── MOCTrigerStrategy.cpp       # 触发策略基类
│   ├── MOCTrigerAbsTimeStrategy.cpp      # 绝对时间触发
│   ├── MOCTrigerRelTimeStrategy.cpp      # 相对时间触发
│   ├── MOCTrigerPipeMassStrategy.cpp     # 管道流量触发
│   ├── MOCTrigerPipeVelStrategy.cpp      # 管道流速触发
│   ├── MOCTrigerSpeedStrategy.cpp        # 转速触发
│   └── ... (更多触发策略)
│
└── 计算控制
    ├── MOCCalcMgr.cpp        # 计算管理器
    ├── MOCCalcModel.cpp      # 计算模型
    ├── MOCSteady.cpp         # 稳态计算
    ├── MOCTrans.cpp          # 瞬变计算
    └── MOCFluid.cpp          # 流体属性
```

## 2.3 新增算法的位置和方法

### 2.3.1 新增节点类型（边界条件）

**位置**：`MocCalc/src/` 和 `MocCalc/inc/`

**步骤**：

1. **创建新的节点类**（继承 MOCJun）：

```cpp
// MocCalc/inc/MOCNewJunction.h
class MOCNewJunction : public MOCJun
{
public:
    MOCNewJunction();
    virtual ~MOCNewJunction();
    
    // 必须实现的虚函数
    static MOCJun* Creator();                    // 工厂方法
    virtual BOOL Read(CalcJun *pData);           // 读取数据
    virtual BOOL InitEndInfo();                  // 初始化端点
    virtual void CalcStm();                      // 稳态计算
    virtual void CalcImpulse(MOCTrans &trans);   // 瞬变计算
    virtual void Result(...);                    // 输出结果
    
private:
    // 新节点的参数
    double m_dNewParam1;
    int m_nNewParam2;
};
```

2. **注册到工厂**（`MOCJunFactory.cpp`）：

```cpp
// 在 MOCJunFactory::Init() 中添加
m_creatorMap[NEW_JUN_TYPE] = MOCNewJunction::Creator;
```

3. **添加数据类**（`CalcDriver/`）：

```cpp
// CalcDriver/inc/CalcNewJunction.h
class CalcNewJunction : public CalcJun
{
    // 定义数据接口
};
```

4. **添加界面支持**（`AutoPFA/`）

**难度**：⭐⭐⭐⭐ 较难

**预计时间**：3-5天

### 2.3.2 新增计算策略

**位置**：`MocCalc/src/xxxStrategy.cpp`

**示例**：添加新的阻力计算策略

```cpp
// MocCalc/inc/NewResistanceStrategy.h
class NewResistanceStrategy : public IStrategy
{
public:
    virtual void Execute(EndListRef& endList, double dK, double dArea);
};

// MocCalc/src/NewResistanceStrategy.cpp
void NewResistanceStrategy::Execute(EndListRef& endList, double dK, double dArea)
{
    // 实现新的阻力计算逻辑
}
```

**难度**：⭐⭐⭐ 中等

**预计时间**：1-2天

### 2.3.3 新增摩擦系数模型

**位置**：`MocCalc/src/CalcFriction.cpp`

**当前支持的摩擦模型**：
- Darcy-Weisbach
- Hazen-Williams
- Manning

**添加新模型**：

```cpp
// 在 CalcFriction.cpp 中添加
double CalcFriction::CalcNewModel()
{
    // 实现新的摩擦系数计算公式
    double dF = /* 新公式 */;
    return dF;
}

// 在 CalcF() 中添加分支
double CalcFriction::CalcF()
{
    switch(m_nFrictionModel)
    {
    case 0: return CalcDarcyWeisbach();
    case 1: return CalcHazenWilliams();
    case 2: return CalcManning();
    case 3: return CalcNewModel();  // 新增
    }
}
```

**难度**：⭐⭐ 简单

**预计时间**：半天

### 2.3.4 新增泵模型

**位置**：`MocCalc/src/MOCPump*.cpp`

**当前支持**：
- 四象限完整特性曲线
- 集中惯性模型
- 无惯性简化模型

**添加步骤**：
1. 继承 `MOCPumpModel` 基类
2. 实现 `CalcImpulse()` 方法
3. 在 `PumpTransModelMgr.cpp` 中注册

**难度**：⭐⭐⭐⭐ 较难

**预计时间**：3-5天

### 2.3.5 新增触发器类型

**位置**：`MocCalc/src/MOCTriger*.cpp`

**示例**：添加基于温度的触发器

```cpp
// MOCTrigerTemperatureStrategy.h
class MOCTrigerTemperatureStrategy : public MOCTrigerStrategy
{
public:
    virtual BOOL IsTriger(MOCTrans& trans);
    virtual void Read(TranControlData& data);
private:
    double m_dTargetTemperature;
};
```

**难度**：⭐⭐⭐ 中等

**预计时间**：1-2天

## 2.4 算法扩展接口

### 2.4.1 CalcInterface 接口层

用于数据模型与计算模型之间的转换：

```
AFTDriver (数据存储)
    ↓
CalcInterface (数据转换)
    ↓
CalcDriver (计算数据)
    ↓
MocCalc (算法计算)
```

新增节点类型需要在每一层都添加对应的类。

### 2.4.2 扩展点总结

| 扩展类型 | 位置 | 难度 | 预计时间 |
|---------|------|------|---------|
| 新摩擦模型 | CalcFriction.cpp | ⭐⭐ | 半天 |
| 新计算策略 | xxxStrategy.cpp | ⭐⭐⭐ | 1-2天 |
| 新触发器 | MOCTrigerxxx.cpp | ⭐⭐⭐ | 1-2天 |
| 新节点类型 | MOCxxx.cpp + 全套 | ⭐⭐⭐⭐ | 3-5天 |
| 新泵模型 | MOCPumpxxx.cpp | ⭐⭐⭐⭐ | 3-5天 |
| 全新计算方法 | 新模块 | ⭐⭐⭐⭐⭐ | 1-2周 |

## 2.5 开发建议

### 2.5.1 代码规范

1. **命名规范**：
   - 类名：`MOC` + 功能名（如 `MOCNewValve`）
   - 成员变量：`m_` 前缀 + 类型缩写（如 `m_dValue`, `m_nCount`）

2. **继承结构**：
   - 节点类继承 `MOCJun`
   - 策略类继承对应的基类
   - 使用工厂模式创建对象

3. **设计模式**：
   - 工厂模式（节点创建）
   - 策略模式（计算策略）
   - 迭代器模式（遍历集合）

### 2.5.2 调试建议

1. 使用 `TRACE` 宏输出调试信息
2. 使用 `ASSERT` 检查前置条件
3. 单元测试先在简单管网上验证

### 2.5.3 参考文档

- `开发文档/` 目录下的设计文档
- `开发文档/文件接口/AFT文件格式/` - 数据格式说明
- 现有类似功能的代码实现

---

## 附录：关键文件路径快速参考

| 功能 | 文件路径 |
|------|---------|
| 主程序图标 | `AutoPFA/res/AutoPFA.ico` |
| 工具栏图标 | `AutoPFA/res/Toolbar.bmp` |
| 组件面板 | `AutoPFA/res/palette.bmp` |
| 资源定义 | `AutoPFA/Resource.h` |
| 管道计算 | `MocCalc/src/MOCPipe.cpp` |
| 节点基类 | `MocCalc/src/MOCJun.cpp` |
| 节点工厂 | `MocCalc/src/MOCJunFactory.cpp` |
| 摩擦计算 | `MocCalc/src/CalcFriction.cpp` |
| 稳态计算 | `MocCalc/src/MOCSteady.cpp` |
| 瞬变计算 | `MocCalc/src/MOCTrans.cpp` |
| 触发器管理 | `MocCalc/src/MOCTrigerMgr.cpp` |

---

**文档版本**：1.0  
**最后更新**：2026年1月11日

